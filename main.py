# -*- coding: utf-8 -*-
"""main

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1V_QDrNUUHgDMIuPyzq1-dK6eumELFrVE

Import das bibliotecas
"""

# Commented out IPython magic to ensure Python compatibility.
import cv2
import numpy as np
from matplotlib import pyplot as plt
from matplotlib import image
import math
#import statistics as stat
from scipy import stats
import os
from glob import glob
import pandas as pd
import PIL #manipulação de imagens
from PIL import Image
import csv
# %matplotlib inline

"""**Lendo e exibindo a imagem.**

A função **imread()** possui um segundo argumento que especifica como a imagem deve ser lida.

* cv2.IMREAD_COLOR     = **1**: Le a imagem como **colorida**.

* cv2.IMREAD_GRAYSCALE = **0**: Le a imagem em **escala de cinza**.

* cv2.IMREAD_UNCHANGED = **-1**: Le incluindo o **canal alfa**.


Ler todas as imagens na pasta e plotar

"""

def imgShow(imagem, parametro):

  if parametro == 1:
    img = cv2.imread(imagem, parametro)
    plt.imshow(img)
    plt.show()
    return img
  else:
    # no openCV as imagens são BGR então é necessário converter para RGB
    img = cv2.cvtColor(image.imread(imagem), cv2.COLOR_BGR2RGB)
    img_cinza = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    plt.imshow(img_cinza,cmap='gray')
    plt.show()
    return (img_cinza)

"""# **Dados estatísticos**

*   Dimensões da imagem
*   Valor máximo
*   Valor mínimo
"""

# Dados estatísticos
def imgDim(imagem):
  print("Dimensões da imagem: alt x larg  \n")
  print(imagem.shape)
  return (imagem.shape)

def imgMax(imagem):
  print("Valor máximo da imagem   \n")
  print(imagem.max())
  return (imagem.max())

def imgMin(imagem):
  print("Valor mínimo da imagem   \n")
  print(imagem.min())
  return (imagem.min())

"""# **Média**
O valor médio de uma imagem digital é calculado pelo somatório
dos valores de níveis de cinza de todos os píxeis da imagem dividido
pelo número total de píxeis
"""

# Valor médio dos pixeis da imagem
def imgMedia(imagem):
  v_medio = cv2.mean(imagem)
  print("Media \n")
  print(v_medio)
  return (v_medio)

"""# **Variância**

A variância da imagem digital representa o valor de desvio dos níveis
de cinza da imagem em relação ao nível de cinza médio
"""

def imgVariancia(imagem):
  v_variancia = np.var(imagem)
  print("Variancia \n")
  return (v_variancia)

"""# **Mediana**

A mediana é determinada pelo valor de nível de cinza
que divide a imagem em dois grupos de tamanhos iguais. Para se calcular
este indicador é fundamental uma ordenação dos níveis de cinza da
imagem
"""

def imgMediana(imagem):
  v_mediana = np.median(imagem)
  print("Mediana \n")
  print(v_mediana)
  return (v_mediana)

"""# **Desvio padrão**

O desvio padrão representa a raiz quadrada da variância e informa sobre a
maior ou menor homogeneidade, ou heterogeneidade, de uma imagem
digital.
"""

def imgDesvio(imagem):
  v_desvioPadrao = np.std(imagem)
  print("Desvio Padrão \n")
  print(v_desvioPadrao)
  return (v_desvioPadrao)

"""# **Moda**

A moda é o nível de cinza mais frequente na imagem. Para se
calcular este parâmetro é necessário calcular a frequência de todos os
níveis de cinza na imagem e determinar aquele de maior frequência
"""

def imgModa(imagem):
  v_Moda = stats.mode(imagem)
  print("Moda \n")
  print(v_Moda)
  return (v_Moda)

"""# **Co-variância**

A co-variância entre duas ou mais imagens digitais (obrigatoriamente
do mesmo tamanho e resolução), relaciona a presença (ou não) de
redundância de informação entre essas imagens.

A correlação entre duas imagens i e j é definida pela co-variância entre
essas duas imagens e normalizada pelo produto de seus respectivos
desvios padrões.

Este índice de correlação varia entre -1 e 1. Valores próximos a -1 e a 1
indicam alta correlação negativa e positiva, respectivamente. Um valor
próximo a 0 indica baixo índice de correlação entre as imagens, isto é, um
valor alto de um píxel da figura i não significa um valor alto no píxel
correspondente da figura j.

# **Histograma**

O histograma é um gráfico que relaciona cada valor de nível de cinza
com a sua frequência de aparecimento na imagem digital. 
Eixo "X" = niveis de cinza
Eixo "Y" = frequencia dos pixeis do respectivo nível de cinza


Histogramas com médias baixas = imagens mais escuras
Histogramas com médias altas  = imagens mais claras

Histogramas com desvio padrão baixo = imagens homogêneas (pouca variabilidade)
Histogramas com desvio padrão alto = imagens heterogéneas (grande variabilidade)

*   Qualidade da imagem
*   Intensidade Luminosa
*   Contraste
"""

def imgHistograma (imagem, parametro):
  if parametro == 1:
    plt.hist(imagem.ravel(), 256, [0,256])
    plt.title("Histograma da imagem BGR")
    plt.show()
  else:
    img_gray = cv2.cvtColor(imagem, cv2.COLOR_BGR2GRAY)
    plt.imshow(img_gray,cmap='gray')
    plt.show()
    plt.hist(img_gray.ravel(), 256, [0,256], color = 'gray')
    plt.title("Histograma da imagem em tons de cinza")
    plt.show() 
    return

"""Histograma por canal (azul, verde, vermelho)"""

def imgHistogramChanel (imagem):

    azul, verde, vermelho = cv2.split(imagem)
    
    fig = plt.figure(figsize=(20,5))

    ax1 = fig.add_subplot(131)
    ax1.hist(azul.ravel(), 256, [0,256], color = 'b')
    plt.title("Histograma do canal azul")

    ax2 = fig.add_subplot(132)
    ax2.hist(verde.ravel(), 256, [0,256], color = 'g')
    plt.title("Histograma do canal verde")

    ax3 = fig.add_subplot(133)
    ax3.hist(vermelho.ravel(), 256, [0,256], color = 'r')
    plt.title("Histograma do canal vermelho")

    plt.show()
    return

def imgHistogramaLinhas(imagem):
# img = cv2.imread('path da imagem')
  color = ('b','g','r')
  for i, col in enumerate(color):
	  histr = cv2.calcHist([imagem], [i], None, [256], [0, 256])
	  plt.plot(histr, color = col)
	  plt.xlim([0, 256])

  plt.title("Gráfico da relação dos canais BGR da imagem")
  plt.show()
  return

def imgEqualize(imagem):
  # A equalização de histograma é para apenas 1 canal de cor, então a imagem tem que estar em tons de cinza
    img_gray = cv2.cvtColor(imagem,cv2.COLOR_BGR2GRAY)
    img_eq = cv2.equalizeHist(img_gray)
    plt.hist(img_eq.ravel(), 256, [0,256], color = 'gray')
    plt.title("Histograma tons de cinza equalizado")
    plt.show()
    return

"""# **Filtros**"""

def filtroMedia(imagem):
  print('Filtros de média = substitui o pixel da imagem pelo valor médio da vizinhança')
  img_gray = cv2.cvtColor(imagem,cv2.COLOR_BGR2GRAY)

  imgM3 = cv2.blur(img_gray, (3,3))
  imgM5 = cv2.blur(img_gray, (5,5))
  imgM7 = cv2.blur(img_gray, (7,7))
  imgM9 = cv2.blur(img_gray, (9,9))
  
  fig = plt.figure(figsize=(20,5))

  ax1 = fig.add_subplot(141)
  ax1.imshow(imgM3, cmap='gray')
  plt.title("Imagem com ruído 3")

  ax2 = fig.add_subplot(142)
  ax2.imshow(imgM5, cmap='gray')
  plt.title("Imagem com ruído 5")

  ax3 = fig.add_subplot(143)
  ax3.imshow(imgM7, cmap='gray')
  plt.title("Imagem com ruído 7")
  
  ax4 = fig.add_subplot(144)
  ax4.imshow(imgM9, cmap='gray')
  plt.title("Imagem com ruído 9")

  plt.show()
  return

def filtroGauss(imagem):
  print('Filtros Gaussiano')
  img_gray = cv2.cvtColor(imagem,cv2.COLOR_BGR2GRAY)

  imgM3 = cv2.GaussianBlur(img_gray, (3,3), 0)
  imgM5 = cv2.GaussianBlur(img_gray, (5,5), 0)
  imgM7 = cv2.GaussianBlur(img_gray, (7,7), 0)
  imgM9 = cv2.GaussianBlur(img_gray, (9,9), 0)
  
  fig = plt.figure(figsize=(20,5))

  ax1 = fig.add_subplot(141)
  ax1.imshow(imgM3, cmap='gray')
  plt.title("Filtro Gauss com ruído 3")

  ax2 = fig.add_subplot(142)
  ax2.imshow(imgM5, cmap='gray')
  plt.title("Filtro Gauss com ruído 5")

  ax3 = fig.add_subplot(143)
  ax3.imshow(imgM7, cmap='gray')
  plt.title("Filtro Gauss com ruído 7")
  
  ax4 = fig.add_subplot(144)
  ax4.imshow(imgM9, cmap='gray')
  plt.title("Filtro Gauss com ruído 9")

  plt.show()
  return

"""Filtro Sobel = Detecção de bordas"""

def filtroSobel(imagem):
  print('Filtros Sobel - Realçar bordas verticais e horizontais')
  img_gray = cv2.cvtColor(imagem,cv2.COLOR_BGR2GRAY)

  img3_sobelx = cv2.Sobel(img_gray, cv2.CV_8U, 0, 1, ksize = 3)
  img3_sobely = cv2.Sobel(img_gray, cv2.CV_8U, 1, 0, ksize = 3)

  img5_sobelx = cv2.Sobel(img_gray, cv2.CV_8U, 0, 1, ksize = 5)
  img5_sobely = cv2.Sobel(img_gray, cv2.CV_8U, 1, 0, ksize = 5)

  img7_sobelx = cv2.Sobel(img_gray, cv2.CV_8U, 0, 1, ksize = 7)
  img7_sobely = cv2.Sobel(img_gray, cv2.CV_8U, 1, 0, ksize = 7)

  img9_sobelx = cv2.Sobel(img_gray, cv2.CV_8U, 0, 1, ksize = 9)
  img9_sobely = cv2.Sobel(img_gray, cv2.CV_8U, 1, 0, ksize = 9)


  fig = plt.figure(figsize=(20,5))

  ax1 = fig.add_subplot(141)
  ax1.imshow(img3_sobelx, cmap='gray')
  plt.title("Filtro SobelX com ruído 3")

  ax2 = fig.add_subplot(142)
  ax2.imshow(img5_sobelx, cmap='gray')
  plt.title("Filtro SobelX com ruído 5")

  ax3 = fig.add_subplot(143)
  ax3.imshow(img7_sobelx, cmap='gray')
  plt.title("Filtro SobelX com ruído 7")

  ax4 = fig.add_subplot(144)
  ax4.imshow(img9_sobelx, cmap='gray')
  plt.title("Filtro SobelX com ruído 9")

  ax5 = fig.add_subplot(441)
  ax5.imshow(img3_sobely, cmap='gray')
  plt.title("Filtro SobelY com ruído 3")

  ax6 = fig.add_subplot(442)
  ax6.imshow(img5_sobely, cmap='gray')
  plt.title("Filtro SobelY com ruído 5")

  ax7 = fig.add_subplot(443)
  ax7.imshow(img7_sobely, cmap='gray')
  plt.title("Filtro SobelY com ruído 7")

  ax8 = fig.add_subplot(444)
  ax8.imshow(img9_sobely, cmap='gray')
  plt.title("Filtro SobelY com ruído 9")  

  plt.show()
  return

"""Filtro Laplaciano = Detecção de bordas mais finas que o Sobel (por definição usa janela = 3)

# media = a partir de qual valor a imagem serah binarizada
  thresh1 = cv2.threshold(img_gray,media,255,cv2.THRESH_BINARY)
  thresh2 = cv2.threshold(img_gray,media,255,cv2.THRESH_BINARY_INV)
  thresh3 = cv2.threshold(img_gray,media,255,cv2.THRESH_TOZERO)
  thresh4 = cv2.threshold(img_gray,media,255,cv2.THRESH_TOZERO_INV)

  fig = plt.figure(figsize=(20,5))

  ax1 = fig.add_subplot(141)
  ax1.imshow(thresh1)
  plt.title("THRESH_BINARY")

  ax2 = fig.add_subplot(142)
  ax2.imshow(thresh2)
  plt.title("THRESH_BINARY_INV")

  ax3 = fig.add_subplot(143)
  ax3.imshow(thresh3)
  plt.title("THRESH_TOZERO")

  ax4 = fig.add_subplot(144)
  ax4.imshow(thresh3)
  plt.title("THRESH_TOZERO_INV")

  plt.show()
"""

def filtroThreshold(imagem, media):
  img_gray = cv2.cvtColor(imagem,cv2.COLOR_BGR2GRAY)
  # a media retorna valores para os 3 canais, mas preciso apenas do primeiro
  #v_media = media[0] 
  for v_media in range(0, 255, 30):
    ret,thresh1 = cv2.threshold(img_gray,v_media,255,cv2.THRESH_BINARY)
    ret,thresh2 = cv2.threshold(img_gray,v_media,255,cv2.THRESH_BINARY_INV)
    ret,thresh3 = cv2.threshold(img_gray,v_media,255,cv2.THRESH_TRUNC)
    ret,thresh4 = cv2.threshold(img_gray,v_media,255,cv2.THRESH_TOZERO)
    ret,thresh5 = cv2.threshold(img_gray,v_media,255,cv2.THRESH_TOZERO_INV)
    
    print("corte = ")
    print(v_media)
    fig = plt.figure(figsize=(20,5))

    ax1 = fig.add_subplot(141)
    ax1.imshow(thresh1, cmap ='gray')
    plt.title("THRESH_BINARY")

    ax2 = fig.add_subplot(142)
    ax2.imshow(thresh2, cmap ='gray')
    plt.title("THRESH_BINARY_INV")

    ax3 = fig.add_subplot(143)
    ax3.imshow(thresh3, cmap ='gray')
    plt.title("THRESH_TOZERO - variações do cinza e fixa o branco")

    ax4 = fig.add_subplot(144)
    ax4.imshow(thresh3, cmap ='gray')
    plt.title("THRESH_TOZERO_INV - variações do cinza e fixa o branco")

  #  titles = ['Original Image','BINARY','BINARY_INV','TRUNC','TOZERO','TOZERO_INV']
  #  images = [img_gray, thresh1, thresh2, thresh3, thresh4, thresh5]

  #  for i in range(6):
  #    plt.subplot(2,3,i+1),plt.imshow(images[i],'gray')
  #    plt.title(titles[i])
  #    plt.xticks([]),plt.yticks([])

    plt.show()

  return

"""# **INICIO**

Lendo as imagens do diretorio
"""

#Endereco das imagens
caminho = '/content/drive/MyDrive/Rafael/Teste/'
img_names = glob(os.path.join(caminho,'*.png'))

dados = pd.DataFrame(columns=['arquivo', 'largura', 'altura', 'pixel maximo', 'pixel minimo', 'pixel medio', 'pixel mediana', 'variancia', 'desvio padrão'])

cont = 0
for img in img_names:
  print("Path da imagem lida")
  print(img)
  print("Mostrando as imagens coloridas e tons de cinza")
  img_cor   = imgShow(img, 1) #colorida
  img_cinza = imgShow(img, 0) #tons de cinza
  
  print("Mostra os dados estatísticos")
  #   Dimensões da imagem
  img_alt, img_larg = imgDim(img_cinza)
  # #   Valor máximo dos pixeis 
  img_max =  imgMax(img_cinza)
  # #   Valor mínimo dos pixeis 
  img_min =  imgMin(img_cinza)
  # #   Média dos pixeis
  img_media = imgMedia(img_cinza)
  #   Variancia dos pixeis da imagem
  img_var = imgVariancia(img_cinza)
  #   Mediana dos pixeis da imagem
  img_mediana = imgMediana(img_cinza)
  #   Desvio Padrão dos pixeis da imagem
  img_desvio = imgDesvio(img_cinza)

  # Inserindo dados no dataframe
  dados.loc[cont] = ({'arquivo' : img , 'largura' : img_larg, 'altura': img_alt, 'pixel maximo': img_max, 'pixel minimo': img_min, 'pixel medio' : img_media, 'pixel mediana' : img_mediana, 'variancia': img_var, 'desvio padrão' : img_desvio })

  #   Histogramas
  # imgHistograma(img_cor,1)
  # imgHistogramChanel(img_cor)
  # imgHistogramaLinhas(img_cor)
  plt.title("Imagem em escala cinza")
  imgHistograma(img_cor,0)
  # imgEqualize(img_cor)

  #   Filtros
  filtroMedia(img_cor)
  filtroGauss(img_cor)
  filtroSobel(img_cor)
  filtroThreshold(img_cor, img_media)
  # filtroLaplaciano(img_cor)
  # filtroCanny(img_cor)

# Tratar imagens OBJ.
  cont = cont + 1

print(dados)

#@title Texto de título padrão
with open('/content/drive/MyDrive/Rafael/Teste/relatorio.csv', 'w', newline='', encoding='utf-8' ) as arquivo_csv:
  dados.to_csv(arquivo_csv)
arquivo_csv.close()